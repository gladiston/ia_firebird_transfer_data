# Criando scripts de transferencia de dados entre bancos Firebird
Usando IA para criar script psql do Firebird para transferir dados de uma base de dados Firebird oara outra.
Uma instrução completa de como fazer isso, segue abaixo.
Se você usa DOMAINs, insira-os no passo 2, se forem muitos anexe num .md separado todos os domains que usa e seus tipos(não precisa das constraints neles) como mostrado no passo.  

# Objetivo  
O objetivo é fazer transferencia de dados de uma tabela para outra incluindo databases diferentes.

# Vantagens  
As vantagens são: velocidade e flexibilidade.  
A transferencia é muito mais rapida do que usando programas como FBCopy ou IBDataPump porque acontecem entre servidores sem nenhum midware entre eles.
Também há flexibilidade, foi incluida uma variavel vPODE_TRANSF que permiti incluir IFs dentro do script para desviar um registro de ser transferido. Também cada campo do registro é transferido para uma variavel, por exemplo 'DESCRICAO' para 'vDESCRICAO', caso voce queira transformar o valor, basta modificar vDESCRICAO.  

# INICIO DO PROMPT 

1. Aqui vamos criar scripts .sql que transferem os arquivos de um servidor de banco de dados antigo para outro mais novo.
* Fornecido uma estrutura de tabela como o seguinte exemplo:
```
CREATE TABLE ADMIN_CALENDARIO (
    ID_CALENDARIO  BIGINT GENERATED BY DEFAULT AS IDENTITY,
    DESCRICAO      VARCHAR(250) DEFAULT NULL,
    LOGINNAME      VARCHAR(32) DEFAULT CURRENT_USER NOT NULL,
    DT_INICIAL     DATE DEFAULT '1970-01-01',
    DT_FINAL       DATE DEFAULT '1970-01-01',
    STATUS         CHAR(1) DEFAULT 'A' ,
    STATUS_COM     COMPUTED BY (
  cast(
    case
        when status='A' then 'Ativo'
        when status='C' then 'Cancelado'
        when status='P' THEN 'Pessoal'
        when status='M' THEN 'Movel'
        when status='F' then 'Fixo'
        else 'Indefinido'
    end AS VARCHAR(30))
    ),
    LAST_UPDATE    TIMESTAMP DEFAULT current_timestamp NOT NULL,
    LAST_OWNER     VARCHAR(32) DEFAULT CURRENT_USER NOT NULL,
    MODIFICADO_EM  COMPUTED BY (
      cast(
        case
          when (last_update <= '01.01.1970') then 'Inalterado'
          when (coalesce(last_owner, '') = '') then
          left(left(cast(last_update as varchar(30)), 16) || ' anonimo', 40)
        else
          left(left(cast(last_update as varchar(30)), 16) || ' ' || left(last_owner, 30), 40)
      end as varchar(40)))
);
```

2. Como pode ver no script 'CREATE TABLE' há domains que são tipos criados pelo proprio usuário que refereciam tipos primitivos e seus tamanhos. Leia o arquivo domains.md e saberá qual os tipos primitivos e seus tamanho para cada domain, ex:  
```
  ID_CALENDARIO -> BINGINT
  LOGINNAME ->VARCHAR(32)
  DT_INICIAL -> DATE
  DT_FINAL -> DATE
  DESCRICAO ->VARCHAR(250)
  STATUS ->CHAR(1)
```  
Voce usará os tipos primitivos ao inves de domains dentro do script que será gerado.   

3. Voce deve devolver um script de transferencia de dados do antigo banco para o novo usando este script como esse modelo:  
```
-- Transferencia de dados da tabela ADMIN_CALENDARIO com paginacao  
SET NAMES ISO8859_1;  
SET TERM ^ ;  

EXECUTE BLOCK AS
  DECLARE ins_sql VARCHAR(8000);
  DECLARE sel_sql VARCHAR(4096);
  DECLARE vSKIP_HASDATA BOOLEAN = TRUE;
  DECLARE vPODE_TRANSF BOOLEAN = TRUE;
  -- credenciais e conexão do banco de origem
  DECLARE vDB_FROM_HOST     VARCHAR(255) = 'localhost';
  DECLARE vDB_FROM_PORT     VARCHAR(10)  = '8050';
  DECLARE vDB_FROM_DATABASE VARCHAR(255) = 'fonte.fdb';
  DECLARE vDB_FROM_USERNAME VARCHAR(63)  = 'SYSDBA';
  DECLARE vDB_FROM_PASSWORD VARCHAR(63)  = 'masterkey';
  DECLARE vDB_FROM_CONN     VARCHAR(512);
  -- variáveis de destino (tipos primitivos conforme domains)
  DECLARE vID_CALENDARIO BIGINT;          -- D_ROWID
  DECLARE vLOGINNAME     VARCHAR(32);     -- D_CURRENT_USER
  DECLARE vDT_INICIAL    DATE;            -- D_DATA
  DECLARE vDT_FINAL      DATE;            -- D_DATA
  DECLARE vDESCRICAO     VARCHAR(250);    -- D_DESCRICAO
  DECLARE vSTATUS        CHAR(1);         -- D_STATUS
  DECLARE vLAST_UPDATE   TIMESTAMP;       -- D_CURRENT_TIME
  DECLARE vLAST_OWNER    VARCHAR(32);     -- D_CURRENT_USER
  -- controle de paginação
  DECLARE vBatchSize INTEGER = 1000;
  DECLARE vOffset    INTEGER = 0;
  DECLARE vFetched   INTEGER;
  DECLARE vHasMore   BOOLEAN = TRUE;
  -- controle de carga sem PK (só se destino vazio)
  DECLARE vDestIsEmpty BOOLEAN;
BEGIN
  -- monta a string de conexao
  vDB_FROM_CONN = vDB_FROM_HOST || '/' || vDB_FROM_PORT || ':' || vDB_FROM_DATABASE;

  -- pular completamente se já houver dados (comportamento global)
  IF (vSKIP_HASDATA) THEN
  BEGIN
    IF (EXISTS(SELECT * FROM ADMIN_CALENDARIO ROWS 1)) THEN EXIT;
  END

  -- tabela sem PK: só transfere se destino estiver vazio
  vDestIsEmpty = NOT EXISTS(SELECT * FROM ADMIN_CALENDARIO ROWS 1);
  IF (NOT vDestIsEmpty) THEN
  BEGIN
    EXIT;
  END

  -- comando de inserção (sem MATCHING, pois não há PK declarada)
  ins_sql =
    'INSERT INTO ADMIN_CALENDARIO ('||
    '  ID_CALENDARIO,'||
    '  LOGINNAME,'||
    '  DT_INICIAL,'||
    '  DT_FINAL,'||
    '  DESCRICAO,'||
    '  STATUS,'||
    '  LAST_UPDATE,'||
    '  LAST_OWNER'||
    ') VALUES ('||
    '  :p_id_calendario,'||
    '  :p_loginname,'||
    '  :p_dt_inicial,'||
    '  :p_dt_final,'||
    '  :p_descricao,'||
    '  :p_status,'||
    '  :p_last_update,'||
    '  :p_last_owner'||
    ')';

  -- loop paginado usando FIRST/SKIP (sem setar timeout na origem)
  WHILE (vHasMore) DO
  BEGIN
    vFetched = 0;

    sel_sql =
      'SELECT FIRST '||vBatchSize||' SKIP '||vOffset||' '||
      '  ID_CALENDARIO,'||
      '  LOGINNAME,'||
      '  DT_INICIAL,'||
      '  DT_FINAL,'||
      '  DESCRICAO,'||
      '  STATUS,'||
      '  LAST_UPDATE,'||
      '  LAST_OWNER '||
      'FROM ADMIN_CALENDARIO '||
      'ORDER BY ID_CALENDARIO';

    FOR
      EXECUTE STATEMENT :sel_sql
      ON EXTERNAL :vDB_FROM_CONN
        AS USER :vDB_FROM_USERNAME
        PASSWORD :vDB_FROM_PASSWORD
    INTO
      vID_CALENDARIO,
      vLOGINNAME,
      vDT_INICIAL,
      vDT_FINAL,
      vDESCRICAO,
      vSTATUS,
      vLAST_UPDATE,
      vLAST_OWNER
    DO BEGIN
      vPODE_TRANSF = TRUE;
      IF (vPODE_TRANSF) THEN
      BEGIN
        EXECUTE STATEMENT (ins_sql)
          ( p_id_calendario := vID_CALENDARIO,
            p_loginname     := vLOGINNAME,
            p_dt_inicial    := vDT_INICIAL,
            p_dt_final      := vDT_FINAL,
            p_descricao     := vDESCRICAO,
            p_status        := vSTATUS,
            p_last_update   := vLAST_UPDATE,
            p_last_owner    := vLAST_OWNER
          );
      END
      vFetched = vFetched + 1;
    END

    vOffset = vOffset + vBatchSize;
    IF (vFetched < vBatchSize) THEN vHasMore = FALSE;
  END
END^
SET TERM ; ^
```  

4. Então, quando eu fornecer uma estrutura de tabela, devolva um script para transferencia como o exemplo mostrado. 
5. Os campos usam tipos que chamamos de domains, se voce olhar o arquivo 'domains.md' que anexei então descobrirá qual é o tipo primitivo e tamanho real de cada um, sempre que possivel, use o tipo primitivo e tamanho, mas se não achar use 'TYPE OF COLUMN' para herdar o tipo nativo da coluna de destino.  
6. Colunas computadas devem ser ignoradas, mas não precisa comentar que as removeu.  
7. Se a instrução 'create table' fornecida contiver chave primaria(primary key), use 'UPDATE OR INSERT(...) MATCHING(...)' para garantir a transferencia de todos os registros, mas se não houver uma chave primaria, use  'IF (NOT EXISTS(SELECT * FROM TABELA)) THEN' para executar a transferencia apenas se a tabela de destino estiver vazia e neste caso use 'INSERT INTO' ao inves de 'UPDATE OR INSERT(...) MATCHING(...)'.  
8. A variavel vPODE_TRANSF deve sempre existir com valor inicial 'true'.   
9. Tambem o FOR..EXECUTE STATEMENT deve ter um BEGIN na linha seguinte conforme o modelo.
```   
  DO BEGIN
    vPODE_TRANSF=true;
    IF (vPODE_TRANSF) then
    BEGIN
      EXECUTE STATEMENT (ins_sql)...
    END
  END
```
Isso ira facilitar caso eu queira criar outro IF mudando o valor de vPODE_TRANSF.  
11. As variaveis que não forem referencias a campo de tabela devem estar no inicio do bloco.  
12. Entre as linhas que declaram as variaveis não devem existir linhas em branco.  
13. Crie uma variavel vSKIP_HASDATA (no topo do bloco) do tipo BOOLEAN com valor inicial true. Quando este valor for true, confira se a tabela de destino possui dados e se existir simplesmente pule a transferencia. Manualmente poderei mudar para 'false' para forçar a transferencia.  

# FIM DO PROMPT  

É isso, faça bom uso.
